# -*- coding: utf-8 -*-
"""1.generate_points_bb.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11Yav4EG2WwdR6-E0WoXQeZGEGNLHR7FV
"""

!rm -rf waymo-od > /dev/null
!git clone https://github.com/waymo-research/waymo-open-dataset.git waymo-od
!cd waymo-od && git branch -a
!cd waymo-od && git checkout remotes/origin/master
!pip3 install --upgrade pip

!pip3 install waymo-open-dataset-tf-2-11-0==1.6.1

!python --version

import os
import tensorflow.compat.v1 as tf
import math
import numpy as np
import itertools
import pickle

tf.enable_eager_execution()

from waymo_open_dataset.utils import range_image_utils
from waymo_open_dataset.utils import transform_utils
from waymo_open_dataset.utils import  frame_utils
from waymo_open_dataset import dataset_pb2 as open_dataset

from google.colab import drive

drive.mount('/content/gdrive')
#读取序列tfrecord
FILENAME = '/content/gdrive/MyDrive/Colab Notebooks/individual_files_training_segment-10500357041547037089_1474_800_1494_800_with_camera_labels.tfrecord'
dataset = tf.data.TFRecordDataset(FILENAME)
file_name = os.path.basename(FILENAME)
#规定保存路径
folder_path = os.path.join('/content/gdrive/MyDrive/ColabNotebooks/points', file_name.split('.')[0])
os.makedirs(folder_path, exist_ok=True)

# frame_count = 156  # 设置起始帧数为74
# for i, data in enumerate(dataset, 1):  # 从1开始枚举以匹配帧数
#     if i < 156:
#         continue  # 跳过前74个帧
frame_count = 1
for data in dataset:
	frame = open_dataset.Frame()
	frame.ParseFromString(bytearray(data.numpy()))
	(range_images, camera_projections, seg_labels, range_image_top_pose) = frame_utils.parse_range_image_and_camera_projection(frame)
	(point,cp_point) = frame_utils.convert_range_image_to_point_cloud(frame,range_images,camera_projections,range_image_top_pose)#获取激光点云
	points, cp_points = frame_utils.convert_range_image_to_point_cloud(frame, range_images, camera_projections, range_image_top_pose, keep_polar_features=True)
	points_all = np.concatenate(points, axis=0)

	points_bb = []
# Iterate through all points in points_all
	for point in points_all:
    # Check if the point is inside any of the bounding boxes in laser_labels
		for laser_labels in frame.laser_labels:
        # Check if the point is inside the bounding box
  			if (point[3] >= laser_labels.box.center_x - 0.5 * laser_labels.box.length and
            point[3] <= laser_labels.box.center_x + 0.5 * laser_labels.box.length and
            point[4] >= laser_labels.box.center_y - 0.5 * laser_labels.box.width and
            point[4] <= laser_labels.box.center_y + 0.5 * laser_labels.box.width and
            point[5] >= laser_labels.box.center_z - 0.5 * laser_labels.box.height and
            point[5] <= laser_labels.box.center_z + 0.5 * laser_labels.box.height):
            # If the point is inside the bounding box, add it to points_bb
						points_bb.append(point)

# Convert points_bb to a numpy array
	points_bb = np.array(points_bb)
	file_path = os.path.join(folder_path, f"points_{frame_count}.pkl")
	with open(file_path, 'wb') as file:
		pickle.dump(points_bb, file)
	print(f"Data saved successfully to {file_path}")
	frame_count += 1