# -*- coding: utf-8 -*-
"""original_data_analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TCceZ59nQyK6sogcvKSnC0bG-UKUkOcj
"""

!rm -rf waymo-od > /dev/null
!git clone https://github.com/waymo-research/waymo-open-dataset.git waymo-od
!cd waymo-od && git branch -a
!cd waymo-od && git checkout remotes/origin/master
!pip3 install --upgrade pip

!pip3 install waymo-open-dataset-tf-2-11-0==1.6.1

import os
import tensorflow.compat.v1 as tf
import math
import numpy as np
import itertools

tf.enable_eager_execution()

from waymo_open_dataset.utils import range_image_utils
from waymo_open_dataset.utils import transform_utils
from waymo_open_dataset.utils import  frame_utils
from waymo_open_dataset import dataset_pb2 as open_dataset

from google.colab import drive
drive.mount('/content/gdrive')
import os
print(os.path.exists('/content/gdrive/My Drive/ColabNotebooks/test.tfrecord'))

#提取并输出其中每一帧包含的信息
FILENAME = '/content/gdrive/My Drive/ColabNotebooks/tfrecord/individual_files_training_segment-10526338824408452410_5714_660_5734_660_with_camera_labels.tfrecord'
dataset = tf.data.TFRecordDataset(FILENAME)

for data in dataset:
	frame = open_dataset.Frame()
	frame.ParseFromString(bytearray(data.numpy()))
	print(frame.context)
	break

(range_images, camera_projections, seg_labels, range_image_top_pose) = frame_utils.parse_range_image_and_camera_projection(frame)
(point,cp_point) = frame_utils.convert_range_image_to_point_cloud(frame,range_images,camera_projections,range_image_top_pose)#获取激光点云
print(range_images)

#图片数据及标签可视化
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import pprint

def show_camera_image(camera_image, camera_labels, layout, cmap=None):
	 """Show a camera image and the given camera labels."""
	 ax = plt.subplot(*layout)

	 # Draw the camera labels.
	 for camera_labels in frame.camera_labels:
	 	# Ignore camera labels that do not correspond to this camera.
	    if camera_labels.name != camera_image.name:
	    	continue

	    # Iterate over the individual labels.
	    for label in camera_labels.labels:
	    	# Draw the object bounding box.
	     	ax.add_patch(patches.Rectangle(xy=(label.box.center_x - 0.5 * label.box.length,
	           							   label.box.center_y - 0.5 * label.box.width),
	       							       width=label.box.length,
	       								   height=label.box.width,
	       							       linewidth=1,
	       								   edgecolor='red',
	       								   facecolor='none'))

	 # Show the camera image.
	 plt.imshow(tf.image.decode_jpeg(camera_image.image), cmap=cmap)
	 plt.title(open_dataset.CameraName.Name.Name(camera_image.name))
	 plt.grid(False)
	 plt.axis('off')

plt.figure(figsize=(25, 20))

for index, image in enumerate(frame.images):
	show_camera_image(image, frame.camera_labels, [3, 3, index+1])

"""center_x: X-coordinate of the center of the bounding box.

center_y: Y-coordinate of the center of the bounding box.

center_z: Z-coordinate of the center of the bounding box.

heading: Heading or orientation of the bounding box.

height: Height of the bounding box.

length: Length of the bounding box.

width: Width of the bounding box.
"""

#range图片可视化
plt.figure(figsize=(64, 20))
def plot_range_image_helper(data, name, layout, vmin = 0, vmax=1, cmap='gray'):
	"""Plots range image.

	Args:
	  data: range image data
	  name: the image title
	  layout: plt layout
	  vmin: minimum value of the passed data
	  vmax: maximum value of the passed data
	  cmap: color map
	"""
	plt.subplot(*layout)
	plt.imshow(data, cmap=cmap, vmin=vmin, vmax=vmax)
	plt.title(name)
	plt.grid(False)
	plt.axis('off')

def get_range_image(laser_name, return_index):
	"""Returns range image given a laser name and its return index."""
	return range_images[laser_name][return_index]

def show_range_image(range_image, layout_index_start = 1):
	"""Shows range image.

	Args:
	  range_image: the range image data from a given lidar of type MatrixFloat.
	  layout_index_start: layout offset
	"""
	range_image_tensor = tf.convert_to_tensor(range_image.data)
	range_image_tensor = tf.reshape(range_image_tensor, range_image.shape.dims)
	print(range_image_tensor)
	lidar_image_mask = tf.greater_equal(range_image_tensor, 0)
	range_image_tensor = tf.where(lidar_image_mask, range_image_tensor,
	                              tf.ones_like(range_image_tensor) * 1e10)
	range_image_range = range_image_tensor[...,0]
	range_image_intensity = range_image_tensor[...,1]
	range_image_elongation = range_image_tensor[...,2]
	plot_range_image_helper(range_image_range.numpy(), 'range',
	                 [8, 1, layout_index_start], vmax=75, cmap='gray')
	plot_range_image_helper(range_image_intensity.numpy(), 'intensity',
	                 [8, 1, layout_index_start + 1], vmax=1.5, cmap='gray')
	plot_range_image_helper(range_image_elongation.numpy(), 'elongation',
	                 [8, 1, layout_index_start + 2], vmax=1.5, cmap='gray')

frame.lasers.sort(key=lambda laser: laser.name)
show_range_image(get_range_image(open_dataset.LaserName.TOP, 0), 1)
show_range_image(get_range_image(open_dataset.LaserName.TOP, 1), 4)

print(get_range_image(open_dataset.LaserName.FRONT, 0).shape)

#点云转换和可视化
points, cp_points = frame_utils.convert_range_image_to_point_cloud(frame, range_images, camera_projections, range_image_top_pose)
points_ri2, cp_points_ri2 = frame_utils.convert_range_image_to_point_cloud(frame, range_images, camera_projections, range_image_top_pose, ri_index=1)

# 3d points in vehicle frame.
points_all = np.concatenate(points, axis=0)
points_all_ri2 = np.concatenate(points_ri2, axis=0)
# camera projection corresponding to each point.
cp_points_all = np.concatenate(cp_points, axis=0)
cp_points_all_ri2 = np.concatenate(cp_points_ri2, axis=0)

print(points_all.shape)
print(cp_points_all.shape)
print(points_all[0:2])
for i in range(5):
	print(points[i].shape)
	print(cp_points[i].shape)

print(points_all_ri2.shape)
print(cp_points_all_ri2.shape)
print(points_all_ri2[0:2])
for i in range(5):
	print(points_ri2[i].shape)
	print(cp_points_ri2[i].shape)

from IPython.display import Image, display
display(Image('/content/waymo-od/tutorial/3d_point_cloud.png'))

for point in points_all[:10]:
    print(point)

# 遍历帧中的激光雷达标签
for laser_labels in frame.laser_labels:
    # 获取激光雷达标签对象的所有属性信息并打印
    label_attributes = laser_labels.ListFields()
    print("Laser label attributes:")
    for attribute_name, attribute_value in label_attributes:
        print(f"{attribute_name.name}: {attribute_value}")
    print("")

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# 创建一个3D图形
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
fig.set_size_inches(20, 16)
# 遍历每个边界框信息并绘制
for laser_labels in frame.laser_labels:
    center_x = laser_labels.box.center_x
    center_y = laser_labels.box.center_y
    center_z = laser_labels.box.center_z
    width = laser_labels.box.width
    length = laser_labels.box.length
    height = laser_labels.box.height
    heading = laser_labels.box.heading

    # 计算边界框的八个顶点坐标
    vertices = [
        [center_x - width / 2, center_y - length / 2, center_z - height / 2],
        [center_x + width / 2, center_y - length / 2, center_z - height / 2],
        [center_x + width / 2, center_y + length / 2, center_z - height / 2],
        [center_x - width / 2, center_y + length / 2, center_z - height / 2],
        [center_x - width / 2, center_y - length / 2, center_z + height / 2],
        [center_x + width / 2, center_y - length / 2, center_z + height / 2],
        [center_x + width / 2, center_y + length / 2, center_z + height / 2],
        [center_x - width / 2, center_y + length / 2, center_z + height / 2]
    ]

    # 将边界框的顶点连接起来，并添加到图形上
    lines = [
        [vertices[0], vertices[1], vertices[2], vertices[3], vertices[0]],
        [vertices[4], vertices[5], vertices[6], vertices[7], vertices[4]],
        [vertices[0], vertices[4]],
        [vertices[1], vertices[5]],
        [vertices[2], vertices[6]],
        [vertices[3], vertices[7]]
    ]

    for line in lines:
        ax.plot3D(*zip(*line), color='r')

# 设置图形的坐标轴标签
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')


# 设置 x 轴刻度的位置和标签
#ax.set_xticks(range(-60, 81, 10))
ax.set_box_aspect([10, 5, 5])

for point in point_bb:
    ax.scatter(point.x, point.y, point.z, color='b')
# 显示图形
plt.show()

import numpy as np

# Initialize an empty list to store points inside the bounding boxes
points_bb = []

# Iterate through all points in points_all
for point in points_all:
    # Check if the point is inside any of the bounding boxes in laser_labels
    for laser_labels in frame.laser_labels:
        # Check if the point is inside the bounding box
        if (point[0] >= laser_labels.box.center_x - 0.5 * laser_labels.box.length and
            point[0] <= laser_labels.box.center_x + 0.5 * laser_labels.box.length and
            point[1] >= laser_labels.box.center_y - 0.5 * laser_labels.box.width and
            point[1] <= laser_labels.box.center_y + 0.5 * laser_labels.box.width and
            point[2] >= laser_labels.box.center_z - 0.5 * laser_labels.box.height and
            point[2] <= laser_labels.box.center_z + 0.5 * laser_labels.box.height):
            # If the point is inside the bounding box, add it to points_bb
            points_bb.append(point)

# Convert points_bb to a numpy array
points_bb = np.array(points_bb)

print("Size of points_bb:", points_bb.shape)
print("Contents of points_bb:")
print(points_bb)

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# 创建一个3D图形
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
fig.set_size_inches(20, 16)
# 遍历每个边界框信息并绘制
for laser_labels in frame.laser_labels:
    center_x = laser_labels.box.center_x
    center_y = laser_labels.box.center_y
    center_z = laser_labels.box.center_z
    width = laser_labels.box.width
    length = laser_labels.box.length
    height = laser_labels.box.height
    heading = laser_labels.box.heading

    # 计算边界框的八个顶点坐标
    vertices = [
        [center_x - width / 2, center_y - length / 2, center_z - height / 2],
        [center_x + width / 2, center_y - length / 2, center_z - height / 2],
        [center_x + width / 2, center_y + length / 2, center_z - height / 2],
        [center_x - width / 2, center_y + length / 2, center_z - height / 2],
        [center_x - width / 2, center_y - length / 2, center_z + height / 2],
        [center_x + width / 2, center_y - length / 2, center_z + height / 2],
        [center_x + width / 2, center_y + length / 2, center_z + height / 2],
        [center_x - width / 2, center_y + length / 2, center_z + height / 2]
    ]

    # 将边界框的顶点连接起来，并添加到图形上
    lines = [
        [vertices[0], vertices[1], vertices[2], vertices[3], vertices[0]],
        [vertices[4], vertices[5], vertices[6], vertices[7], vertices[4]],
        [vertices[0], vertices[4]],
        [vertices[1], vertices[5]],
        [vertices[2], vertices[6]],
        [vertices[3], vertices[7]]
    ]

    for line in lines:
        ax.plot3D(*zip(*line), color='r')

# 设置图形的坐标轴标签
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')


# 设置 x 轴刻度的位置和标签
#ax.set_xticks(range(-60, 81, 10))
ax.set_box_aspect([10, 3, 3])
for point in points_bb:
    ax.scatter(point[0], point[1], point[2], color='b',s=2)
# 显示图形
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# 数据集1
points_all = np.concatenate(points, axis=0)
cp_points_all = np.concatenate(cp_points, axis=0)

# 数据集2
points_all_ri2 = np.concatenate(points_ri2, axis=0)
cp_points_all_ri2 = np.concatenate(cp_points_ri2, axis=0)

# 创建三维图
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

# 可视化数据集1
ax.scatter(points_all[:, 0], points_all[:, 1], points_all[:, 2], c='b', marker='o', label='Point Cloud 1')

# 可视化数据集2
#ax.scatter(points_all_ri2[:, 0], points_all_ri2[:, 1], points_all_ri2[:, 2], c='r', marker='s', label='Point Cloud 2')

# 设置坐标轴标签
ax.set_xlabel('X Label')
ax.set_ylabel('Y Label')
ax.set_zlabel('Z Label')

# 添加图例
ax.legend()

# 显示图形
plt.show()

#点云数据投影
images = sorted(frame.images, key=lambda i:i.name)
cp_points_all_concat = np.concatenate([cp_points_all, points_all], axis=-1)
cp_points_all_concat_tensor = tf.constant(cp_points_all_concat)

# The distance between lidar points and vehicle frame origin.
points_all_tensor = tf.norm(points_all, axis=-1, keepdims=True)
cp_points_all_tensor = tf.constant(cp_points_all, dtype=tf.int32)

mask = tf.equal(cp_points_all_tensor[..., 0], images[0].name)

cp_points_all_tensor = tf.cast(tf.gather_nd(
    cp_points_all_tensor, tf.where(mask)), dtype=tf.float32)
points_all_tensor = tf.gather_nd(points_all_tensor, tf.where(mask))

projected_points_all_from_raw_data = tf.concat(
    [cp_points_all_tensor[..., 1:3], points_all_tensor], axis=-1).numpy()

def rgba(r):
	"""Generates a color based on range.

	Args:
	  r: the range value of a given point.
	Returns:
	  The color for a given range
	"""
	c = plt.get_cmap('jet')((r % 20.0) / 20.0)
	c = list(c)
	c[-1] = 0.5  # alpha
	return c

def plot_image(camera_image):
	"""Plot a cmaera image."""
	plt.figure(figsize=(20, 12))
	plt.imshow(tf.image.decode_jpeg(camera_image.image))
	plt.grid("off")

def plot_points_on_image(projected_points, camera_image, rgba_func,
                         point_size=5.0):
	"""Plots points on a camera image.

	Args:
	projected_points: [N, 3] numpy array. The inner dims are
	[camera_x, camera_y, range].
	camera_image: jpeg encoded camera image.
	rgba_func: a function that generates a color from a range value.
	point_size: the point size.

	"""
	plot_image(camera_image)

	xs = []
	ys = []
	colors = []

	for point in projected_points:
	  xs.append(point[0])  # width, col
	  ys.append(point[1])  # height, row
	  colors.append(rgba_func(point[2]))

	plt.scatter(xs, ys, c=colors, s=point_size, edgecolors="none")

plot_points_on_image(projected_points_all_from_raw_data,
                     images[0], rgba, point_size=5.0)

